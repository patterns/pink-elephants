
pub const wasi_outbound_http_string_t = extern struct {
    ptr: [*c]u8,
    len: usize,
};
pub export fn wasi_outbound_http_string_set(arg_ret: [*c]wasi_outbound_http_string_t, arg_s: [*c]const u8) void {
    var ret = arg_ret;
    var s = arg_s;
    ret.*.ptr = @intToPtr([*c]u8, @ptrToInt(s));
    ret.*.len = strlen(s);
}


pub const wasi_outbound_http_tuple2_string_string_t = extern struct {
    f0: wasi_outbound_http_string_t,
    f1: wasi_outbound_http_string_t,
};

pub const wasi_outbound_http_headers_t = extern struct {
    ptr: [*c]wasi_outbound_http_tuple2_string_string_t,
    len: usize,
};

pub const wasi_outbound_http_http_error_t = u8;
pub const wasi_outbound_http_http_status_t = u16;

pub const wasi_outbound_http_params_t = extern struct {
    ptr: [*c]wasi_outbound_http_tuple2_string_string_t,
    len: usize,
};


pub const wasi_outbound_http_request_t = extern struct {
    method: wasi_outbound_http_method_t,
    uri: wasi_outbound_http_uri_t,
    headers: wasi_outbound_http_headers_t,
    params: wasi_outbound_http_params_t,
    body: wasi_outbound_http_option_body_t,
};

pub const wasi_outbound_http_option_headers_t = extern struct {
    is_some: bool,
    val: wasi_outbound_http_headers_t,
};

pub const wasi_outbound_http_response_t = extern struct {
    status: wasi_outbound_http_http_status_t,
    headers: wasi_outbound_http_option_headers_t,
    body: wasi_outbound_http_option_body_t,
};





pub export fn wasi_outbound_http_request(arg_req: [*c]wasi_outbound_http_request_t, arg_ret0: [*c]wasi_outbound_http_response_t) wasi_outbound_http_http_error_t {
    var req = arg_req;
    var ret0 = arg_ret0;
    var ptr: i32 = @intCast(i32, @ptrToInt(&RET_AREA));

    __wasm_import_wasi_outbound_http_request(
@bitCast(i32, @as(c_uint, req.*.method)),
 @intCast(i32, @ptrToInt(req.*.uri.ptr)),
 @bitCast(i32, @truncate(c_uint, req.*.uri.len)),
 @intCast(i32, @ptrToInt(req.*.headers.ptr)),
 @bitCast(i32, @truncate(c_uint, req.*.headers.len)),
 @intCast(i32, @ptrToInt(req.*.params.ptr)), @bitCast(i32, @truncate(c_uint, req.*.params.len)),
 option, option1, option2, ptr);

    var expected: wasi_outbound_http_expected_response_http_error_t = undefined;
    while (true) {
        switch (@bitCast(i32, @as(c_uint, @intToPtr([*c]u8, ptr + @as(c_int, 0)).*))) {
            @as(c_int, 0) => {
                {
                    expected.is_err = @as(c_int, 0) != 0;
                    var option3: wasi_outbound_http_option_headers_t = undefined;
                    while (true) {
                        switch (@bitCast(i32, @as(c_uint, @intToPtr([*c]u8, ptr + @as(c_int, 8)).*))) {
                            @as(c_int, 0) => {
                                {
                                    option3.is_some = @as(c_int, 0) != 0;
                                    break;
                                }
                            },
                            @as(c_int, 1) => {
                                {
                                    option3.is_some = @as(c_int, 1) != 0;
                                    option3.val = wasi_outbound_http_headers_t{
                                        .ptr = @intToPtr([*c]wasi_outbound_http_tuple2_string_string_t, @intToPtr([*c]i32, ptr + @as(c_int, 12)).*),
                                        .len = @bitCast(usize, @as(c_long, @intToPtr([*c]i32, ptr + @as(c_int, 16)).*)),
                                    };
                                    break;
                                }
                            },
                            else => {},
                        }
                        break;
                    }
                    var option4: wasi_outbound_http_option_body_t = undefined;
                    while (true) {
                        switch (@bitCast(i32, @as(c_uint, @intToPtr([*c]u8, ptr + @as(c_int, 20)).*))) {
                            @as(c_int, 0) => {
                                {
                                    option4.is_some = @as(c_int, 0) != 0;
                                    break;
                                }
                            },
                            @as(c_int, 1) => {
                                {
                                    option4.is_some = @as(c_int, 1) != 0;
                                    option4.val = wasi_outbound_http_body_t{
                                        .ptr = @intToPtr([*c]u8, @intToPtr([*c]i32, ptr + @as(c_int, 24)).*),
                                        .len = @bitCast(usize, @as(c_long, @intToPtr([*c]i32, ptr + @as(c_int, 28)).*)),
                                    };
                                    break;
                                }
                            },
                            else => {},
                        }
                        break;
                    }
                    expected.val.ok = wasi_outbound_http_response_t{
                        .status = @bitCast(u16, @truncate(c_short, @bitCast(i32, @as(c_uint, @intToPtr([*c]u16, ptr + @as(c_int, 4)).*)))),
                        .headers = option3,
                        .body = option4,
                    };
                    break;
                }
            },
            @as(c_int, 1) => {
                {
                    expected.is_err = @as(c_int, 1) != 0;
                    expected.val.err = @bitCast(wasi_outbound_http_http_error_t, @truncate(i8, @bitCast(i32, @as(c_uint, @intToPtr([*c]u8, ptr + @as(c_int, 4)).*))));
                    break;
                }
            },
            else => {},
        }
        break;
    }
    ret0.* = expected.val.ok;
    return @bitCast(wasi_outbound_http_http_error_t, @truncate(i8, if (@as(c_int, @boolToInt(expected.is_err)) != 0) @bitCast(c_int, @as(c_uint, expected.val.err)) else -@as(c_int, 1)));
}





const union_unnamed_1 = extern union {
    ok: wasi_outbound_http_response_t,
    err: wasi_outbound_http_http_error_t,
};
pub const wasi_outbound_http_expected_response_http_error_t = extern struct {
    is_err: bool,
    val: union_unnamed_1,
};


const std = @import("std");



//////////
// WASI C/interop

// host provided call signature
pub extern "wasi-outbound-http" fn @"request"(i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32) void;

// static memory that we use to share fields to the host
var RET_AREA: [32]u8 align(4) = std.mem.zeroes([32]u8);

// make the "egress" request
fn send(req: anytype) !bool {
//fn send(req: anytype) !*Response {
//idea, use anon struct because outbound is a leaner collection
//      of fields; not the same as http.Request or spin.Request
//      (what is the response struct?)

    var address: i32 = @intCast(i32, @ptrToInt(&RET_AREA));

    // method (expect u8)
    const method = @intCast(i32, req.method);

    // uri
    const uri: []const u8 = req.uri;
    const uri_addr =  @intCast(i32, @ptrToInt(uri.ptr));
    const uri_len =  @bitCast(i32, @truncate(c_uint, uri.len));

    // headers (expect tuples array, alloc needed?)
    const headers = req.headers.items;
    const hdr_addr = @intCast(i32, @ptrToInt(headers.ptr));
    const hdr_len = @intCast(i32, headers.len);

    // todo params

    // body (expect bytes buffer, alloc needed?)
    const bod_buf = req.body;
    var bod_enable: i32 = 0;
    var bod_addr: i32 = 0;
    var bod_len: i32 = 0;
    if (bod_buf.len != 0) {
        bod_enable = 1;
        bod_addr = bod_buf.ptr;
        bod_len = bod_buf.len;
    }

    // ask host to forward http request on our behalf
    @"request"(
        method,
        uri_addr, uri_len,
        hdr_addr, hdr_len,


        bod_enable,
        bod_addr, bod_len,
        address,
    );

    //todo check return code
    //todo marshal response
    return true;
}

pub const WASI_OUTBOUND_HTTP_HTTP_ERROR_SUCCESS = @as(c_int, 0);
pub const WASI_OUTBOUND_HTTP_HTTP_ERROR_DESTINATION_NOT_ALLOWED = @as(c_int, 1);
pub const WASI_OUTBOUND_HTTP_HTTP_ERROR_INVALID_URL = @as(c_int, 2);
pub const WASI_OUTBOUND_HTTP_HTTP_ERROR_REQUEST_ERROR = @as(c_int, 3);
pub const WASI_OUTBOUND_HTTP_HTTP_ERROR_RUNTIME_ERROR = @as(c_int, 4);
pub const WASI_OUTBOUND_HTTP_HTTP_ERROR_TOO_MANY_REQUESTS = @as(c_int, 5);
